# redis 使用规范

## 键值设计

### 1 key命名设计

#### 1.1 命名规范

可以使用的字符：小写英文字母、冒号(:)、数字、下划线

不能使用的字符：空格、换行、单双引号以及其他转义字符

#### 1.2 可读性和可管理性

以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如 `业务名:表名:id`

#### 1.3 简洁性

保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：

`user:{uid}:address:{name}` 简化为 `u:{uid}:addr:{name}`

### 2 value设计

#### 2.1 禁止使用bigkey

由于redis是单线程，针对大key的操作时间会很长会造成堵塞。高QPS情况下会直接造成redis服务崩溃, 过长的指令会触发sentinel执行主从切换。

string类型控制在10KB以内，当key超过10K、100K、1M性能会明显下降。hash、list、set、zset元素个数不要超过5000。

非字符串的bigkey不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时自动删除的问题，例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞。

#### 2.2 选择适合的数据类型

**字符串(String)：**

适合普通的 key/value 存储。较长的json串建议使用Hash类型存放。

**哈希(Hash)：**

适合存储对象。示例：
```
hmset user:1 name tom age 19 favor football
```

上面例子不建议用普通的字符串存储（反例）：
```
set user:1:name tom
set user:1:age 19
set user:1:favor football
```

**列表(List)：**

按插入顺序排序的字符串元素的集合，适合消息队列或者排序结果的存储。redis提供了阻塞式访问 BRPOP 和 BLPOP 命令。消费者可以在获取数据时指定如果数据不存在阻塞的时间。

**集合(Set)：**

set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的接口，这个也是list没有提供的。

**有序集合(Sorted Set):**

sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构。

**Pub/Sub(发布/订阅)：**

适用实时消息推送接收的场景。

**Bitmap：**

用位数组来表示各元素是否出现，每个元素对应一位，所需的总内存为n bit。能大大减少内存占用且位操作迅速。

**HyperLogLog：**

用来做基数统计的算法，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

#### 2.3 控制key的生命周期，所有的key必须设置过期时间

建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，避免存在僵尸key。

## 命令使用

1. **禁止使用的命令**

```
keys、flushall、flushdb、hgetall、lrange、smembers、zrange、sinter
```

如果需要相关功能，请使用scan、hscan、sscan、zscan的方式渐进式处理。

说明：

redis是单线程处理，在线上KEY数量较多时，操作效率极低【时间复杂度为O(N)】，该命令一旦执行会严重阻塞线上其它命令的正常请求，而且在高QPS情况下会直接造成redis服务崩溃！如果有类似需求，请使用scan类命令代替！

2. **禁止使用select**

只允许使用db0， 禁止使用select访问其他db。

redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。

3. **不建议使用redis事务**

redis的事务功能较弱，不支持回滚。

4. **命令的时间复杂度**

redis命令使用原则：

- 时间复杂度为O(1)一般可以放心使用
- 时间复杂度为O(n)谨慎使用，要使用必须保证n比较小（担心出现bug，导致元素累计）
- 时间复杂度为O(log(n))一般可以放心使用，n代表有序集合的基数
- 时间复杂度为O(log(n)+M)，M为结果集的基数，保证M比较小的情况下可以使用

5. **monitor命令**

不能长时间执行，建议运行10s内。因为monitor会增加5%-10%的cpu使用率。

6. **不建议使用高频率ping**

7. **list的消费尽量使用brpop，blpop；并设置timeout参数**

## 过期时间

1. string建议设置过期时间，不要集中过期。

2. list、hash、set、zset的非bigkey是否设置过期时间，具体看业务。

3. list、hash、set、zset的bigkey建议不设置过期时间。

4. 热点key建议不设置过期时间。

## 使用规范

1. 不同业务组，使用不同的redis。

   a. 减少多个业务相互影响

   b. redis支持最大的QPS是有限的

2. redis压力比较大的时候，同一个业务组，不同功能使用不同的redis。

   a. 减少不同功能相互影响

   b. redis支持最大的QPS是有限的

3. 不相干的业务拆分，公共数据做服务化，方便将来redis的拆分。

4. 多个业务之间不要共同使用同一个key。不利于将来redis的拆分。如果要拆分的话，只能再次修改代码提供公共数据的服务。
